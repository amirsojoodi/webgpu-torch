import { Dtype } from "./dtype";
import { Shape } from "./shape";
import { IDevice } from "./device_if";
import { Deviceish } from "./device";
import { UntypedStorage } from "./storage";
import { TensorImpl } from "./tensor_impl";
import { KernelConfigInput, KernelParamsInput } from "./kernel";

export type TensorArrayData = Array<number | TensorArrayData>;

export type TensorJsonData = {
    data: TensorArrayData | TensorImpl;
    dtype: Dtype;
    requiresGrad?: boolean;
    device?: Deviceish;
};

export interface ITensor {
    get storage(): UntypedStorage;
    get dtype(): Dtype;
    get shape(): Shape;
    get device(): IDevice;
    runKernel(name: string, config: KernelConfigInput, params: KernelParamsInput, outputShapes: Shape[], ...additionalInputs: ITensor[]): ITensor[];
    get(...indices: number[]): number | ITensor;
    add_(other: ITensor, alpha?: number): ITensor;
    expand(shape: Shape): ITensor;
    mm(other: ITensor): ITensor;
    sum(axis: number | null): ITensor;
    t(): ITensor;
    // Codegen marker
    abs(): ITensor;
    abs_(): ITensor;
    acos(): ITensor;
    acos_(): ITensor;
    acosh(): ITensor;
    acosh_(): ITensor;
    add(other: ITensor, alpha?: number): ITensor;
    add_(other: ITensor, alpha?: number): ITensor;
    asin(): ITensor;
    asin_(): ITensor;
    asinh(): ITensor;
    asinh_(): ITensor;
    atan(): ITensor;
    atan_(): ITensor;
    atan2(other: ITensor): ITensor;
    atan2_(other: ITensor): ITensor;
    ceil(): ITensor;
    ceil_(): ITensor;
    copysign(other: ITensor): ITensor;
    copysign_(other: ITensor): ITensor;
    cos(): ITensor;
    cos_(): ITensor;
    cosh(): ITensor;
    cosh_(): ITensor;
    deg2rad(): ITensor;
    deg2rad_(): ITensor;
    div(other: ITensor, alpha?: number): ITensor;
    div_(other: ITensor, alpha?: number): ITensor;
    exp(): ITensor;
    exp_(): ITensor;
    exp2(): ITensor;
    exp2_(): ITensor;
    expm1(): ITensor;
    expm1_(): ITensor;
    floor(): ITensor;
    floor_(): ITensor;
    floor_divide(other: ITensor): ITensor;
    floor_divide_(other: ITensor): ITensor;
    frac(): ITensor;
    frac_(): ITensor;
    hypot(other: ITensor): ITensor;
    hypot_(other: ITensor): ITensor;
    ldexp(other: ITensor): ITensor;
    ldexp_(other: ITensor): ITensor;
    log(): ITensor;
    log_(): ITensor;
    log10(): ITensor;
    log10_(): ITensor;
    log1p(): ITensor;
    log1p_(): ITensor;
    log2(): ITensor;
    log2_(): ITensor;
    logaddexp(other: ITensor): ITensor;
    logaddexp_(other: ITensor): ITensor;
    logaddexp2(other: ITensor): ITensor;
    logaddexp2_(other: ITensor): ITensor;
    mul(other: ITensor, alpha?: number): ITensor;
    mul_(other: ITensor, alpha?: number): ITensor;
    neg(): ITensor;
    neg_(): ITensor;
    positive(): ITensor;
    positive_(): ITensor;
    pow(other: ITensor): ITensor;
    pow_(other: ITensor): ITensor;
    rad2deg(): ITensor;
    rad2deg_(): ITensor;
    reciprocal(): ITensor;
    reciprocal_(): ITensor;
    round(): ITensor;
    round_(): ITensor;
    rsqrt(): ITensor;
    rsqrt_(): ITensor;
    sigmoid(): ITensor;
    sigmoid_(): ITensor;
    sign(): ITensor;
    sign_(): ITensor;
    sin(): ITensor;
    sin_(): ITensor;
    sinc(): ITensor;
    sinc_(): ITensor;
    sinh(): ITensor;
    sinh_(): ITensor;
    sqrt(): ITensor;
    sqrt_(): ITensor;
    square(): ITensor;
    square_(): ITensor;
    sub(other: ITensor, alpha?: number): ITensor;
    sub_(other: ITensor, alpha?: number): ITensor;
    tan(): ITensor;
    tan_(): ITensor;
    tanh(): ITensor;
    tanh_(): ITensor;
    trunc(): ITensor;
    trunc_(): ITensor;
    xlogy(other: ITensor): ITensor;
    xlogy_(other: ITensor): ITensor;
    // End codegen marker
}
