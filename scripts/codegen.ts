import { KernelSpec } from "../src/kernel";
import { CodeWriter, getKernelSpecs } from "../src/op_codegen";
import { OpSpec } from "../src/op_spec";
import { registry } from "../src/op_table";

// import fs
import * as fs from "fs";

console.log("Running code generator...");

const absSrcDir = fs.realpathSync(__dirname + "/../src");
console.log("src dir:", absSrcDir);

// Generate op kernels
const kernelsSpecsIndex: {[name: string]: KernelSpec} = {};
const kernelsSpecs: [OpSpec, KernelSpec][] = [];
for (const spec of registry) {
    const kernels = getKernelSpecs(spec);
    for (const kernel of kernels) {
        kernelsSpecsIndex[kernel.name] = kernel;
        kernelsSpecs.push([spec, kernel]);
    }
}

// Write the kernels
function writeOpKernelsCode(): void {
    const outPath = absSrcDir + "/kernels_opgen.ts";
    const json = JSON.stringify(kernelsSpecsIndex, null, 4);
    console.log("Writing", outPath);
    fs.writeFileSync(outPath, `// Generated by scripts/codegen.ts
// Do not edit this file directly.
import { KernelSpec } from "./kernel";

export const kernels: { [name: string]: KernelSpec } =
${json};
`);
}
writeOpKernelsCode();

function insertCodegenIntoFile(path: string, codegen: string): void {
    const code = fs.readFileSync(path, "utf8");
    const codegenMarker = "// Codegen marker";
    const endCodegenMarker = "// End codegen marker";
    const startIndex = code.indexOf(codegenMarker);
    const endIndex = code.indexOf(endCodegenMarker);
    if (startIndex === -1 || endIndex === -1) {
        throw new Error("Could not find codegen marker in " + path);
    }
    const pre = code.slice(0, startIndex + codegenMarker.length);
    const post = code.slice(endIndex);
    const newCode = pre + "\n" + codegen + "\n    " + post;
    console.log("Writing", path);
    fs.writeFileSync(path, newCode);
}

// Write the TensorWebGPU class
function writeTensorWebGPUCode(): void {
    const w = new CodeWriter();
    w.indent();
    for (const [opSpec, kernelSpec] of kernelsSpecs) {
        const isInplace = kernelSpec.name.endsWith("_");
        const isBinary = opSpec.type === "binary";
        const hasAlpha = opSpec.alpha ?? false;
        if (isBinary) {
            if (hasAlpha) {
                w.writeLine(`${kernelSpec.name}(other: TensorWebGPU, alpha?: number): TensorWebGPU {`);
            }
            else {
                w.writeLine(`${kernelSpec.name}(other: TensorWebGPU): TensorWebGPU {`);
            }
            w.indent();
            w.writeLine(`const kernel = this._device.getKernel("${kernelSpec.name}", { dtype: "f32" });`);
            w.writeLine(`const params = {`);
            w.indent();
            w.writeLine(`size: shapeSize(this.shape),`);
            if (hasAlpha) {
                w.writeLine(`alpha: alpha || 1.0,`);
            }
            w.dedent();
            w.writeLine(`};`);
            if (isInplace) {
                w.writeLine(`kernel.run([other.gpuBuffer], params, [this.gpuBuffer]);`);
                w.writeLine(`return this;`);
            }
            else {
                w.writeLine(`const outputBuffer = kernel.run([this.gpuBuffer, other.gpuBuffer], params)[0];`);
                w.writeLine(`return new TensorWebGPU(`);
                w.indent();
                w.writeLine(`new GPUBufferStorage(outputBuffer, this.gpuDevice),`);
                w.writeLine(`this.dtype,`);
                w.writeLine(`this.shape,`);
                w.writeLine(`defaultStrides(this.shape),`);
                w.writeLine(`this._device`);
                w.dedent();
                w.writeLine(`);`);
            }
            w.dedent();
            w.writeLine(`}`);
        }
        else {
            if (hasAlpha) {
                w.writeLine(`${kernelSpec.name}(alpha?: number): TensorWebGPU {`);
            }
            else {
                w.writeLine(`${kernelSpec.name}(): TensorWebGPU {`);
            }
            w.indent();
            w.writeLine(`const kernel = this._device.getKernel("${kernelSpec.name}", { dtype: "f32" });`);
            w.writeLine(`const params = {`);
            w.indent();
            w.writeLine(`size: shapeSize(this.shape),`);
            if (hasAlpha) {
                w.writeLine(`alpha: alpha || 1.0,`);
            }
            w.dedent();
            w.writeLine(`};`);
            if (isInplace) {
                w.writeLine(`kernel.run([], params, [this.gpuBuffer]);`);
                w.writeLine(`return this;`);
            }
            else {
                w.writeLine(`const outputBuffer = kernel.run([this.gpuBuffer], params)[0];`);
                w.writeLine(`return new TensorWebGPU(`);
                w.indent();
                w.writeLine(`new GPUBufferStorage(outputBuffer, this.gpuDevice),`);
                w.writeLine(`this.dtype,`);
                w.writeLine(`this.shape,`);
                w.writeLine(`defaultStrides(this.shape),`);
                w.writeLine(`this._device`);
                w.dedent();
                w.writeLine(`);`);
            }
            w.dedent();
            w.writeLine(`}`);
        }
    }
    const code = w.toString();
    // console.log(code);
    const path = absSrcDir + "/tensor_webgpu.ts";
    insertCodegenIntoFile(path, code);
}
writeTensorWebGPUCode();

// Write the Tensor class
function writeTensorCode(): void {
    const w = new CodeWriter();
    w.indent();
    for (const [opSpec, kernelSpec] of kernelsSpecs) {
        const isInplace = kernelSpec.name.endsWith("_");
        const isBinary = opSpec.type === "binary";
        const hasAlpha = opSpec.alpha ?? false;
        if (isBinary) {
            if (hasAlpha) {
                w.writeLine(`${kernelSpec.name}(other: Tensor, alpha?: number): Tensor {`);
                w.indent();
                if (isInplace) {
                    w.writeLine(`this._impl.${kernelSpec.name}(other._impl, alpha);`);
                    w.writeLine(`return this;`);
                }
                else {
                    w.writeLine(`return ops.${kernelSpec.name}(this, other, alpha);`);
                }
                w.dedent();
                w.writeLine(`}`);
            }
            else {
                w.writeLine(`${kernelSpec.name}(other: Tensor): Tensor {`);
                w.indent();
                if (isInplace) {
                    w.writeLine(`this._impl.${kernelSpec.name}(other._impl);`);
                    w.writeLine(`return this;`);
                }
                else {
                    w.writeLine(`return ops.${kernelSpec.name}(this, other);`);
                }
                w.dedent();
                w.writeLine(`}`);
            }
        }
        else {
            if (hasAlpha) {
                w.writeLine(`${kernelSpec.name}(alpha?: number): Tensor {`);
                w.indent();
                if (isInplace) {
                    w.writeLine(`this._impl.${kernelSpec.name}(alpha);`);
                    w.writeLine(`return this;`);
                }
                else {
                    w.writeLine(`return ops.${kernelSpec.name}(this, alpha);`);
                }
                w.dedent();
                w.writeLine(`}`);
            }
            else {
                w.writeLine(`${kernelSpec.name}(): Tensor {`);
                w.indent();
                if (isInplace) {
                    w.writeLine(`this._impl.${kernelSpec.name}();`);
                    w.writeLine(`return this;`);
                }
                else {
                    w.writeLine(`return ops.${kernelSpec.name}(this);`);
                }
                w.dedent();
                w.writeLine(`}`);
            }
        }
    }
    const code = w.toString();
    // console.log(code);
    const path = absSrcDir + "/tensor.ts";
    insertCodegenIntoFile(path, code);
}
writeTensorCode();
