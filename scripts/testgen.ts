import { CodeWriter } from "../src/opgen";
import { OpSpec, ReductionOpSpec } from "../src/op_spec";
import { opKernelSpecs } from "../src/kernels_opgen";

// import fs
import * as fs from "fs";
import { KernelSpec } from "../src/kernel";

console.log("Running test code generator...");

const absSrcDir = fs.realpathSync(__dirname + "/../src");
console.log("src dir:", absSrcDir);

const pythonTestsPath = `${absSrcDir}/../scripts/testgen_tests.py`;

function writePythonTests() {
    const w = new CodeWriter();
    w.writeLine(`# Generated by scripts/testgen.ts`);
    w.writeLine(`# Do not edit this file directly.`);
    w.writeLine(`import torch`);
    w.writeLine(`import json`);
    w.writeLine(`results = []`);
    w.writeLine(`def tensor_to_list(tensor):`);
    w.indent();
    w.writeLine(`return tensor.detach().numpy().tolist()`);
    w.dedent();
    w.writeLine(`def add_results(op_name, kernel_name, inputs, outputs, grads, gradError):`);
    w.indent();
    w.writeLine(`results.append([op_name, kernel_name, [tensor_to_list(x) for x in inputs], [tensor_to_list(x) for x in outputs], [tensor_to_list(x) for x in grads] if grads is not None else None, gradError])`);
    w.dedent();
    const unaryTestValues = [
        -2.0, -1.0, 0.5, 0.0, 0.5, 1.0, 2.0
    ];
    function shouldOutputKernelSpec(kernelSpec: KernelSpec): boolean {
        const kernelName = kernelSpec.name;
        const isGrad = kernelName.endsWith("Grad");
        if (isGrad) return false;
        if (kernelName == "positive_") return false;
        return true;
    }
    for (var [opSpec, kernelSpec] of opKernelSpecs) {
        if (!shouldOutputKernelSpec(kernelSpec))
            continue;        
        const opName = opSpec.name;
        const kernelName = kernelSpec.name;
        const isUnary = opSpec.type == "unary";
        const isBinary = opSpec.type == "binary";
        const isReduction = opSpec.type == "reduction";
        const isInplace = kernelName.endsWith("_");
        const hasAlpha = opSpec.alpha ?? false;
        if (isUnary) {
            w.writeLine(`def test_${kernelName}_value(value):`);
            w.indent();
            w.writeLine(`grads = []`);
            w.writeLine(`gradError = False`);
            if (isInplace) {
                w.writeLine(`input = torch.tensor([value], dtype=torch.float32)`);
                w.writeLine(`output = input.clone()`);
                w.writeLine(`output.${kernelName}()`);
            }
            else {
                w.writeLine(`input = torch.tensor([value], dtype=torch.float32, requires_grad=True)`);
                w.writeLine(`output = torch.${kernelName}(input)`);
                if (opSpec.backward) {
                    w.writeLine(`try:`);
                    w.indent();
                    w.writeLine(`output.backward()`);
                    w.writeLine(`assert input.grad is not None`);
                    w.writeLine(`grads = [input.grad]`);
                    w.dedent();
                    w.writeLine(`except:`);
                    w.indent();
                    w.writeLine(`gradError = True`);
                    w.dedent();
                }
            }
            w.writeLine(`add_results("${opName}", "${kernelName}", [input], [output], grads, gradError)`);
            w.dedent();
            w.writeLine(`def test_${kernelName}():`);
            w.indent();
            for (const v of unaryTestValues) {
                w.writeLine(`test_${kernelName}_value(${v})`);
            }
            w.dedent();
        }
        else if (isBinary) {
        }
    }
    w.writeLine(`if __name__ == "__main__":`);
    w.indent();
    for (var [opSpec, kernelSpec] of opKernelSpecs) {
        if (!shouldOutputKernelSpec(kernelSpec))
            continue;        
        const kernelName = kernelSpec.name;
        if (opSpec.type !== "unary")
            continue;
        w.writeLine(`test_${kernelName}()`);
        // Use json module to print results with indent
        const jsonOutputPath = `${absSrcDir}/../scripts/testgen_tests_results.json`;
        w.writeLine(`results_json = json.dumps(results, indent=2)`);
        w.writeLine(`with open("${jsonOutputPath}", "w") as f:`);
        w.indent();
        w.writeLine(`f.write(results_json)`);
        w.dedent();
    }
    w.dedent();
    fs.writeFileSync(pythonTestsPath, w.toString(), "utf-8");
}
writePythonTests();

function runPythonTests() {
    const { spawnSync } = require("child_process");
    const pythonPath = "python3";
    const pythonArgs = [pythonTestsPath];
    const pythonResult = spawnSync(pythonPath, pythonArgs);
    const stdout = pythonResult.stdout.toString();
}
runPythonTests();
